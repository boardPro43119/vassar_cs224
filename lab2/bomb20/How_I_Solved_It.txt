Name: Benjamin Prud'homme
Bomb number: 20

Put a brief description of how you solved each phase here: 

Phase1: 
The first line after the initial statement of the phase_1 function is a command to load an effective address into %rsi. Using adg, I could see that this address pointed to the string "I can see Russia from my house!". The next line down checks if this string is equal to some other string, which must be the string I input into the bomb; therefore this had to be the solution to phase 1.

Phase2:
The first piece of phase 2 that jumped out at me was the read_six_numbers function; this told me the answer was probably in the form of six numbers separated by spaces. Sadly, the first time I stepped through the code, having entered in a test string, I mistakenly typed ni instead of si when about to call read_six_numbers, causing an explosion when the read_six_numbers function was executed all at once. I guess I learned the hard way that this function's responsibility is to validate the input format.
When I entered the sample formatted input 1 2 3 4 5 6, execution made it past read_six_numbers and I was able to inspect the rest of the code in the phase_2 function. I noted that by the first compare command, %rsp pointed to the first number of my input, with the rest of the numbers separated by 4 memory locations each. The first two comparisons were relatively straightforward; they simply involved comparing the first and second numbers of the input (by referencing memory 0 and 4 locations after %rsp) with 0 and 1 (which were stored in %rax each time). For the third through sixth numbers, I saw that before each comparison statement, %rax was being set to the sum of the previous two numbers. Therefore, I was able to figure out that the answer to phase 2 was the first 6 Fibonacci numbers: 0 1 1 2 3 5.

Phase3:
The first clue I picked up on was the contents of the address 0x40290d (which was loaded into %rsi early in the function), which indicated that the input should consist of two decimal numbers separated by a space. I reran the function with the input 1 2 and saw that once the __isoc99_sscanf@plt function had finished, 0xc(%rsp) held a 1 and 0x8(%rsp) held a 2 - this led me to conclude that this is where the two input numbers are stored. The first two compare statements also succeeded with this input, and a few lines further down there was an instruction to jump to the address stored in %rax, which happened to be 0x401008. The instructions at that location set %eax to $0x23e (574 in decimal) and checked whether it was equal to the value stored in 0x8(%rsp) (the second number in the input), in which case the phase would successfuly end. Thus, my answer to phase 3 was 1 574.

Phase4:
My first observation for this phase was the "%d %d" stored in %rsi, indicating that the answer was (yet again) two decimal numbers separated by a space. I also found that just like in phase 3, the first input number was being stored at 0xc(%rsp) and the second at 0x8(%rsp). The initial compare statements would cause the bomb to explode if the first number was outside the range [0, 14]. After making it past these, the program proceeded to call the func_4 function, which set effectively set a variable x to the decimal value 14 and performed the following steps:
a) Divide x by 2.
b) If x > (first input number), decrement x and go to step 1.
c) If x < (first input number), increment x and go to step 1.
d) Otherwise, if x == (first input number), set %eax to 0 (thus preventing an explosion in the next test statement that checks that %eax==0) and return.
Following these rules with the input 1 2, x goes from 14 -> 7 -> 6 -> 3 -> 2 -> 1, so the function returns, meaning 1 was a valid first input number. When control returned to the phase_4 function, only one set of statements remained, and it checked that the second input number was 0. Thus, 1 0 was a valid answer.

Phase5:
I first saw the the phase_5 function started out by calling string_length - which set (%eax) to the length of the input string - and exploding if %eax was not 6; thus, this had to be the size of the input string. The set of commands following this compare stored the encodings of 6 characters starting at the location 0x7fffffffe339, but they weren't the same as the original input characters. Through examining these statements carefully, I figured out that the input was being put through a cipher that transformed each character c into the character at the memory location (0x4026b0, (0xf & c), 1). The 16 bytes starting at 0x4026b0 contained the encodings of the characters "maduiersnfotvbyl." Meanwhile, the 6 bytes starting at 0x402686 (which was loaded into %rsi before the strings_not_equal function was called), contained the encodings of the characters of the word "flames." Thus, the answer for this phase had to be a 6-character string that would output "flames" when put through this cipher. Referencing ASCII character codes, I found one possible answer to be "ioapeg."

Phase6:
The first thing to notice in phase_6 was the return of the read_six_numbers function. After calling read_six_numbers, I recognized a nested loop structure that checked to make sure that all input numbers were less than or equal to 6 and that all the numbers were distinct. The next loop structure changed each of the input numbers to 7 minus itself (they were stored 8 bytes apart starting at 0x7fffffffe310). Following that, the code made use of objects node_1, node_2, ..., node_6. By examining the memory contents of these structures, I recognized that each node stored a value, a self-identifying number, and the (little endian) address of the next higher-numbered node - thus, these nodes were structures in a linked list. The following statements loaded the addresses of the nodes whose numbers matched our modified input numbers into memory starting at 0x7fffffffe2e0 (each separated by 8 bytes), and then modified the node pointers so that the node with number (7-first input number) was first in the linked list, the node with number (7-second input number) was second, and so on. The final check the program performed was to verify that when we traversed through the linked list in this order, each node's value (the value at the beginning of its memory) was greater than that of the next. I found the order of nodes from highest to lowest value to be 2, 3, 1, 4, 5, 6. Therefore, the answer to this phase was 7 minus each of these numbers in order: 5 4 6 3 2 1.

SecretPhase:
In the phase_defused function, I noticed a section of code that got executed only after all six phases have been defused that included a call to secret_phase. This section started by loading the location of "%d %d %s" into %rsi and the location of "1 0" (my answer for phase 4) into %rdi; this got me thinking that maybe I had to add some string to the end of the phase 4 input. Sure enough, when I added a test string, after the __isoc99_sscanf@plt function was complete, the program proceeded to compare this additional string (whose address was stored in %rdi) with "DrEvil" (whose address was stored in %rsi). Thus, changing my phase 4 input to "1 0 DrEvil" caused the secret phase to be initiated once the six normal phases were defused.
In the secret_phase function itself, the first set of statements verified that the input was between 1 and 1000. Once this validation was complete, the address of a structure named n1 was loaded into %rdi and control passed to the fun7 function. Inspecting the memory containing n1, I 
